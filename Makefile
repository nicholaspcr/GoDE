# vim: set foldmarker={,} foldlevel=0 foldmethod=marker:
#
#
# This Makefile is heavily inspired by:
# https://github.com/vincentbernat/hellogopher/blob/master/Makefile
#

.PHONY: help
help: ## Shows help message.
	@awk 'BEGIN {FS = ":.*##"; printf "\nUsage:\n  make \033[36m\033[0m\n"} /^[$$()% 0-9a-zA-Z_-]+:.*?##/ { printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2 } /^##@/ { printf "\n\033[1m%s\033[0m\n", substr($$0, 5) } ' $(MAKEFILE_LIST)


.PHONY: init
init: ## Set up all the necessary requirements to run the repository locally.
	@mkdir -p .dev
	@mkdir -p .dev/server
	@mkdir -p .dev/cli
	@mkdir -p .env
	@mkdir -p .env/server
	@mkdir -p .env/cli

.PHONY: deps
deps: ## Downloads dependencies.
	@echo 'Installing dependencies...'
	@go mod download

.PHONY: clean
clean: ## Cleans all the possible dirty files generated by the other go commands.
	@echo 'Checking for files created by go/coverage...'
	@[ -f ./profile.cov ] && rm profile.cov	|| true
	@[ -f ./profile.cov.tmp ] && rm profile.cov.tmp || true
	@echo 'checking for the bin folder...'
	@[ -d ./bin ] && rm -r ./bin || true

.PHONY: proto-lint
proto-lint: ## Runs the linter for the proto files.
	@echo 'Running linter...'
	@buf lint

.PHONY: proto-remove
proto-remove: ## Removes files generated based on the proto definitions.
	@echo 'Removing previous proto files...'
	find . -type f -name \*.pb.gw.go | xargs --no-run-if-empty rm
	find . -type f -name \*.pb.go | xargs --no-run-if-empty rm

.PHONY: proto-generate
proto-generate: ## Generates golang code from proto definitions.
	@buf generate
	@echo 'Done generating protos'

.PHONY: proto
proto: proto-lint proto-remove proto-generate ## Lints and generates proto code

.PHONY: openapi
openapi: ## Generates OpenAPI/Swagger specification from proto files
	@echo 'Generating OpenAPI specification...'
	@mkdir -p docs/openapi
	@buf generate --template buf.gen.openapi.yaml
	@echo 'OpenAPI spec generated at docs/openapi/'

.PHONY: dev
dev: ## Runs the dev environment for all applications.
	@docker compose -f docker-compose.yml up

.PHONY: build
build: ## Builds the binaries for the applications.
	@go build -o ./.dev/decli ./cmd/decli
	@go build -o ./.dev/deserver ./cmd/deserver

.PHONY: test
test: ## Runs all unit tests (excludes e2e).
	@go test -v ./...

.PHONY: test-e2e
test-e2e: ## Runs end-to-end integration tests using testcontainers (requires Docker).
	@echo 'Running e2e tests with testcontainers...'
	@go test -v -tags=e2e -timeout=10m ./test/e2e/...

.PHONY: lint
lint: ## Lints the codebase.
	@golangci-lint run

##@ Kubernetes

.PHONY: k8s-build
k8s-build: ## Build Docker image for Kubernetes deployment
	@echo 'Building Docker image for Kubernetes...'
	@eval $$(minikube docker-env) && docker build -t gode-server:latest .

.PHONY: k8s-deploy
k8s-deploy: ## Deploy to minikube cluster
	@echo 'Deploying to Kubernetes...'
	@kubectl apply -f k8s/configmap.yaml
	@kubectl apply -f k8s/secret.yaml
	@kubectl apply -f k8s/postgres.yaml
	@kubectl apply -f k8s/redis.yaml
	@echo 'Waiting for databases to be ready...'
	@kubectl wait --for=condition=ready pod -l app=postgres --timeout=120s || true
	@kubectl wait --for=condition=ready pod -l app=redis --timeout=60s || true
	@kubectl apply -f k8s/deserver.yaml
	@echo 'Waiting for application to be ready...'
	@kubectl wait --for=condition=ready pod -l app=deserver --timeout=120s || true
	@echo 'Deployment complete!'

.PHONY: k8s-delete
k8s-delete: ## Remove all Kubernetes resources
	@echo 'Deleting Kubernetes resources...'
	@kubectl delete -f k8s/deserver.yaml --ignore-not-found=true
	@kubectl delete -f k8s/redis.yaml --ignore-not-found=true
	@kubectl delete -f k8s/postgres.yaml --ignore-not-found=true
	@kubectl delete -f k8s/secret.yaml --ignore-not-found=true
	@kubectl delete -f k8s/configmap.yaml --ignore-not-found=true
	@kubectl delete pvc postgres-pvc --ignore-not-found=true
	@echo 'Cleanup complete!'

.PHONY: k8s-logs
k8s-logs: ## Show logs from deserver pods
	@kubectl logs -l app=deserver -f --max-log-requests=10

.PHONY: k8s-status
k8s-status: ## Show status of all deployed resources
	@echo 'Deployments:'
	@kubectl get deployments
	@echo '\nPods:'
	@kubectl get pods
	@echo '\nServices:'
	@kubectl get services
	@echo '\nConfigMaps:'
	@kubectl get configmaps
	@echo '\nSecrets:'
	@kubectl get secrets

.PHONY: k8s-url
k8s-url: ## Get the URL to access the application
	@echo 'HTTP Gateway URL:'
	@minikube service deserver-http --url

##@ Frontend

.PHONY: web-deps
web-deps: ## Install frontend dependencies
	@cd web && npm install

.PHONY: web-dev
web-dev: ## Run frontend development server
	@cd web && npm run dev

.PHONY: web-build
web-build: ## Build frontend for production
	@cd web && npm run build

.PHONY: web-test
web-test: ## Run frontend tests
	@cd web && npm run test

.PHONY: web-lint
web-lint: ## Lint frontend code
	@cd web && npm run lint

.PHONY: web-format
web-format: ## Format frontend code with Prettier
	@cd web && npx prettier --write "src/**/*.{ts,tsx}"

.PHONY: web-api
web-api: openapi ## Generate TypeScript API client from OpenAPI spec
	@cd web && npx @openapitools/openapi-generator-cli generate \
		-i ../docs/openapi/api.swagger.json \
		-g typescript-fetch \
		-o src/api/generated \
		--additional-properties=typescriptThreePlus=true,supportsES6=true

.PHONY: dev-full
dev-full: ## Run full stack development (backend + frontend)
	@echo 'Starting PostgreSQL and Redis...'
	@docker compose -f docker-compose.test.yml up -d
	@sleep 3
	@echo 'Run "make run" in one terminal and "make web-dev" in another'

.PHONY: run
run: build ## Build and run the server (sources .dev/server/.env)
	@set -a && . ./.dev/server/.env && set +a && ./.dev/deserver start
